<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C &amp; S</title>
  
  <subtitle>An apple a day keeps the doctor away :)</subtitle>
  <link href="/cancan233.github.io/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-17T05:07:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Cancan Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Connect Google Colab Through SSH</title>
    <link href="http://yoursite.com/2019/10/17/ssh-google-colab/"/>
    <id>http://yoursite.com/2019/10/17/ssh-google-colab/</id>
    <published>2019-10-17T04:14:20.000Z</published>
    <updated>2019-10-17T05:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>Google Colaboratory provides free access to K80 GPU through a Jupyter notebook environment. After continuous 12 hours, the VM will be reset and all data will cleaned. This can be solved by mounting the notebook to your google drive. </p><a id="more"></a><p>Note: If you want to perform some big data training, it is better to download directly to the VM. The limitation of I/O with google drive will slow your training speed.</p><p>However, it is not convenient to move aroud and not a good editor for existing files. </p><p>Thanks for the post <a href="https://imadelhanafi.com/posts/google_colal_server/" target="_blank" rel="noopener">Transform Google Colab to a GPU instance with full SSH access</a>. I have managed to connect to Google Colab through ssh from my local terminal. </p><h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>The workflow in the blog is quite in detail. However, there are some minor mistakes in the post. I will summarize the steps I take to get it work. </p><h2 id="Step-1-Create-a-Ngrok-account"><a href="#Step-1-Create-a-Ngrok-account" class="headerlink" title="Step 1: Create a Ngrok account"></a>Step 1: Create a Ngrok account</h2><p>To achieve the purpose, you will need a Ngrok account to create a working tunnel for port forwarding. You can create it <a href="https://ngrok.com/" target="_blank" rel="noopener">here</a></p><h2 id="Step-2-Start-Google-Colab"><a href="#Step-2-Start-Google-Colab" class="headerlink" title="Step 2: Start Google Colab"></a>Step 2: Start Google Colab</h2><p>I have upload a <a href="https://github.com/cancan233/googlecolab/blob/master/SSH_Google_Colab.ipynb" target="_blank" rel="noopener">template notebook</a> on my Github, which you can open directly using your google account. </p><p>The script provided in the post I mentioned before doesn’t include the password generation part.</p><p>Note: Check <a href="https://colab.research.google.com/github/googlecolab/colabtools/blob/master/notebooks/colab-github-demo.ipynb#scrollTo=K-NVg7RjyeTk" target="_blank" rel="noopener">here</a> for using Google Colab with Github. </p><p>Simply speaking, you need to change the url address of the github<br><code>https://github.com/&lt;path-to-notebook&gt;</code><br>to<br><code>https://colab.research.google.com/github/&lt;path-to-notebook&gt;</code><br>You can also use the Chrome extension <a href="https://chrome.google.com/webstore/detail/open-in-colab/iogfkhleblhcpcekbiedikdehleodpjo" target="_blank" rel="noopener">Open in Colab</a> to generate sun links in one click. </p><h2 id="Step-3-Run-the-notebook-you-open"><a href="#Step-3-Run-the-notebook-you-open" class="headerlink" title="Step 3: Run the notebook you open"></a>Step 3: Run the notebook you open</h2><p>If you follow step 2 and open the template I provide, you can directly run each cell. Follow the authentication procedure and you will see the root password and the ngrok url print at last. If not, you can also check <a href="https://dashboard.ngrok.com/status" target="_blank" rel="noopener">status</a> to see the port number.</p><h2 id="Step-4-SSH-to-Google-Colab"><a href="#Step-4-SSH-to-Google-Colab" class="headerlink" title="Step 4: SSH to Google Colab"></a>Step 4: SSH to Google Colab</h2><p>Open your local terminal and enter command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># port-number is the number you see in ngrok URL</span></span><br><span class="line"><span class="comment"># For example, URL: tcp://0.tcp.ngrok.io:16568, the port number is 16568</span></span><br><span class="line">ssh root@0.tcp.ngrok.io -p &lt;port-number&gt;</span><br></pre></td></tr></table></figure><p>Enter the password you generate in Step 3.</p><p>Enjoy! But remember the VM you connect is Ubuntu 18.04LTS. You will need to install some necessary packages to help you work. I suggest you write a <code>setup.sh</code> for this purpose as you will need to run it every time you open a new Google Colab notebook. </p><p>If you close the Google Colab website, you will still be able to connect to the VM. But I don’t recommend to do so as your VM will be shut down after a while(about half an hour) if you have done that. I am not sure why but I have tested it for several times.</p><h2 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h2><p>If you have connected to the google colab through ssh, you want to create a new jupyter notebook. When you enter <code>jupyter notebook</code> in your terminal, you will see errors. </p><p>Here is a solution <a href="https://ljvmiranda921.github.io/notebook/2018/01/31/running-a-jupyter-notebook/" target="_blank" rel="noopener">Running a Jupyter notebook from a remote server</a>.</p><p>On your ssh terminal window, enter</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X is a port number, pick one not being used</span></span><br><span class="line">jupyter notebook --no-browser --port=XXXX</span><br></pre></td></tr></table></figure><p>On your local terminal, enter</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># YYYY is a port number, pick one not being used</span></span><br><span class="line"><span class="comment"># &lt;port-number&gt; is the ngrok port number</span></span><br><span class="line">ssh -N -f -L localhost:YYY:localhost:XXXX root@0.tcp.ngrok.io -p &lt;port-number&gt;</span><br></pre></td></tr></table></figure><p>You can open the jupyter notebook in your browser in address <code>localhost:YYYY</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h1&gt;&lt;p&gt;Google Colaboratory provides free access to K80 GPU through a Jupyter notebook environment. After continuous 12 hours, the VM will be reset and all data will cleaned. This can be solved by mounting the notebook to your google drive. &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows Subsysem for Linux (WSL)</title>
    <link href="http://yoursite.com/2019/09/20/wsl/"/>
    <id>http://yoursite.com/2019/09/20/wsl/</id>
    <published>2019-09-20T04:51:59.000Z</published>
    <updated>2019-10-07T21:28:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Using-WSL-to-build-your-hexo-blog"><a href="#Using-WSL-to-build-your-hexo-blog" class="headerlink" title="Using WSL to build your hexo blog"></a>Using WSL to build your hexo blog</h2><p>By now, we already know how to sync blog across multiple computers. We could test it on our Windows Subsystem of Linux(WSL) system. The reason I want to use it is because I found my git bash speed is unbearablely slow, while using mobaxterm for wsl shows good running speed. And the most important point is that it is linux environment. </p><a id="more"></a><h3 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h3><p>The first thing you need to do is to install your WSL and the instructions are available on <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">Microsoft Docs</a>. I assume that Ubuntu is installed for the WSL.<br>After you have installed WSL successfully, run following commands to install some basic build tool for WSL.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h3 id="Node-js-npm-hexo-Installation"><a href="#Node-js-npm-hexo-Installation" class="headerlink" title="Node.js, npm, hexo Installation"></a>Node.js, npm, hexo Installation</h3><p>Following the hexo documentation, we download and run intallation script:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure><p>Then, we need to add following to our <code>.bashrc</code> or other shell configuration file.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> <span class="comment"># This loads nvm</span></span><br></pre></td></tr></table></figure><p>Finally, install node.js, npm and hexo-cli.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install stable</span><br><span class="line">sudo apt install npm</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>By now, you could refer to the previous part to write your blog on WSL!</p><h2 id="Conflicting-Distribution"><a href="#Conflicting-Distribution" class="headerlink" title="Conflicting Distribution"></a><a href="https://stackoverflow.com/questions/43857550/how-to-resolve-conflicting-distributions-in-apt-get" target="_blank" rel="noopener">Conflicting Distribution</a></h2><p>When update packages on WSL, I see the error </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W: Conflicting distribution: https://downloads.plex.tv/repo/deb public InRelease (expected public but got )</span><br></pre></td></tr></table></figure><p>The error can be solved with following code.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> deb https://downloads.plex.tv/repo/deb public main | sudo tee /etc/apt/sources.list.d/plexmediaserver.list</span><br><span class="line"></span><br><span class="line">curl https://downloads.plex.tv/plex-keys/PlexSign.key | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure><h2 id="Interesting-Bash-Scripts"><a href="#Interesting-Bash-Scripts" class="headerlink" title="Interesting Bash Scripts"></a><a href="https://github.com/alexanderepstein/Bash-Snippets" target="_blank" rel="noopener">Interesting Bash Scripts</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Using-WSL-to-build-your-hexo-blog&quot;&gt;&lt;a href=&quot;#Using-WSL-to-build-your-hexo-blog&quot; class=&quot;headerlink&quot; title=&quot;Using WSL to build your hexo blog&quot;&gt;&lt;/a&gt;Using WSL to build your hexo blog&lt;/h2&gt;&lt;p&gt;By now, we already know how to sync blog across multiple computers. We could test it on our Windows Subsystem of Linux(WSL) system. The reason I want to use it is because I found my git bash speed is unbearablely slow, while using mobaxterm for wsl shows good running speed. And the most important point is that it is linux environment. &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Journal Club: Unsupervised word embeddings capture latent knowledge from materials science literature</title>
    <link href="http://yoursite.com/2019/09/11/unsupervised-word-embeddings-materials-science/"/>
    <id>http://yoursite.com/2019/09/11/unsupervised-word-embeddings-materials-science/</id>
    <published>2019-09-12T00:29:36.000Z</published>
    <updated>2019-09-15T02:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>This <a href="https://perssongroup.lbl.gov/papers/dagdelen-2019-word-embeddings.pdf" target="_blank" rel="noopener">paper</a> is published on July 03, 2019 on <em>Nature</em> by <a href="https://ceder.berkeley.edu" target="_blank" rel="noopener">Prof. Ceder group</a> at University of California, Berkely. The first author is <a href="https://vtshitoyan.github.io" target="_blank" rel="noopener">Vahe Tshitoyan</a>. Here is an <a href="https://twimlai.com/twiml-talk-291-identifying-new-materials-with-nlp-with-anubhav-jain/" target="_blank" rel="noopener">interview</a> from <a href="https://computron.github.io" target="_blank" rel="noopener">Anubhav Jain</a> talking about the paper.<br><a href="./unsupervised-word-embeddings-materials-science/Journal_club_cancan_20190911.pdf">Here</a> is my presentation slides of this paper on our group meeting Journal Club.</p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>In real life, the majority results of scitific researches are published as text, and structured property databases only cover small portion of the knowledge present in the research literature. For example, publications usually contain valuable knowledge such as connections and relationships interpreted by the authors. Natural language processing provides a method to analyse the latent knowledge that buried in numerous papers. <strong>Conclusions</strong>: The authors said they show information-dense word embedding can capture knowledge present in the published literature. Furthermore, an unsupervised method can recommend materials for functional applications several years before their discovery. </p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>Although the authors only include skip-gram model in their paper, they also did plenty of works on other models such as continuous bag of words(CBOW). Please check if you are interested. Besides the prediction of new functionality of mateirials, they also can predict formation energy of material using word embedding.<br><img src="./algorithm_choice.png" alt></p><p>The main idea of skip-gram model is that it takes every word in the sentence while it also takes one-by-one the words around it within ‘WINDOWSIZE’ to feed into a neural network. In this way, the trained neural network can predict the probability of each word to actually appear in the window around the focus word. The word pair forming can be illustrated as below.<br><img src="./word2vec.png" alt></p><p>They use one-hot encoding to represent each word. Word2vec skip-gram loops through all words in the training text and uses the word pairs in one-hot encoding representation as an input for a neural network. The hyperparameters of Word2vec is optimized on the combined materials science and grammatical analogies. </p><p>For similar words, their word pair will have similar hidden layer weights and therefore similar word embeddings. The softmax functions is used to normalize the output probabilities. To be more specific, Rows of W are called word embeddings and columns of O are called output embeddings. The product of the two types of embeddings is the probability of the corresponding words to be used in close proximity in the text.<br><img src="./model.png" alt></p><h2 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h2><h3 id="Test-1-Comparion-with-computational-dataset"><a href="#Test-1-Comparion-with-computational-dataset" class="headerlink" title="Test 1 Comparion with computational dataset"></a>Test 1 Comparion with computational dataset</h3><p>They compared their predicted thermoelectric compositions with available computational data. A total of 9,483 compounds overlaps in both text and dataset. 7,663 is used as prediction because they are never mentioned alongside thermoelectric keywords in text corpus. </p><p>They ranked these compounds based on the dot product of their normalized output embedding with the word embedding of ‘thermoelectric’. The results are shown in figure below. The top ten predictions provided by their model all exhibit computed power factors significantly greater than the average of candidate materials, and slightly higher than the average of candidate materials. </p><p><img src="./test1.png" alt></p><h3 id="Test-2-Prediction-for-uncovered-properties-of-materials"><a href="#Test-2-Prediction-for-uncovered-properties-of-materials" class="headerlink" title="Test 2 Prediction for uncovered properties of materials"></a>Test 2 Prediction for uncovered properties of materials</h3><p>They tested their model if it have correctly predicted thermoelectric materials reported later in the literature while only trained with text in the past. The overall results are presented below. Grey lines are predictions of their model. Overall, their results indicate that materials from the top 50 word embedding-based predictions(red) were on average eight times more likely to have been studied as thermoelectrics within the next five years as compared to a randomly chosen unstudied material from our corpus at that time (blue) and also three times more likely than a random material with a non-zero DFT bandgap (green).<br><img src="./test2.png" alt></p><p>Moreover, they examine the trend of top five predictions determined using data before 2009. Two of the predictions, ReS2 and CdIn2Te4, were reported within 8-9 years after the point of their first appearence. HgZnTe and SmInO3 are toxic or expensive. Therefore, they are never reported as thermoelectric materials.<br><img src="./test3.png" alt></p><p>Besides thermoelectrics, they also test their model on predicting ‘photovoltaics’, ‘topological insulator’ and ‘ferroelectric’, which show the similar results. They also mentioned that the success of their appoach can partly be attributed to the choice of the training corpus, only abstract. </p><h2 id="Personal-Thinking"><a href="#Personal-Thinking" class="headerlink" title="Personal Thinking"></a>Personal Thinking</h2><p>From their paper, I think that their main success is that they use Word2vec model can successfully predict the reported materials with uncovered properties, which can be a great way to guide scientists to explore the potential of specific materials. </p><p>However, there are also many shortcomings of this method. The prediction is only better than half, which is not appealing to some researchers. And this model still lacks the ability to truly predict the good materials with target property. It can only provide the somewhat good choices from existing materials. </p><p>Some people may be cirtical about this paper. I think the main reason is that the authors have exaggerated a little bit of their prediction results. It may be more appropriate to call it as discovering existing materials with unknown properties.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This &lt;a href=&quot;https://perssongroup.lbl.gov/papers/dagdelen-2019-word-embeddings.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;paper&lt;/a&gt; is published on July 03, 2019 on &lt;em&gt;Nature&lt;/em&gt; by &lt;a href=&quot;https://ceder.berkeley.edu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prof. Ceder group&lt;/a&gt; at University of California, Berkely. The first author is &lt;a href=&quot;https://vtshitoyan.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vahe Tshitoyan&lt;/a&gt;. Here is an &lt;a href=&quot;https://twimlai.com/twiml-talk-291-identifying-new-materials-with-nlp-with-anubhav-jain/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;interview&lt;/a&gt; from &lt;a href=&quot;https://computron.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Anubhav Jain&lt;/a&gt; talking about the paper.&lt;br&gt;&lt;a href=&quot;./unsupervised-word-embeddings-materials-science/Journal_club_cancan_20190911.pdf&quot;&gt;Here&lt;/a&gt; is my presentation slides of this paper on our group meeting Journal Club.&lt;/p&gt;
    
    </summary>
    
    
      <category term="journal club" scheme="http://yoursite.com/tags/journal-club/"/>
    
  </entry>
  
  <entry>
    <title>Journal Club: Quantum convolutional neural networks</title>
    <link href="http://yoursite.com/2019/09/04/Journal-club-20190904/"/>
    <id>http://yoursite.com/2019/09/04/Journal-club-20190904/</id>
    <published>2019-09-04T17:08:32.000Z</published>
    <updated>2019-09-15T00:26:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>This <a href="https://doi.org/10.1038/s41567-019-0648-8" target="_blank" rel="noopener">paper</a> is published on August 26th, 2019 on <em>Nature Physics</em> by <a href="http://lukin.physics.harvard.edu/" target="_blank" rel="noopener">Professor Lukin’s Group</a> at Harvard University. The first author is <a href="https://scholar.google.co.uk/citations?user=Zk3TRxYAAAAJ&hl=en&oi=ao" target="_blank" rel="noopener">Iris Cong</a>, a third-year graduate student. Here are a <a href="(http://www.cchem.berkeley.edu/bqic/slides/qcnn_berkeley_oct18_share.pdf)">talk slides</a> and <a href="https://www.youtube.com/watch?v=ytX6Vfo8WAk" target="_blank" rel="noopener">video</a> from the author introducing this topic and the <a href="https://arxiv.org/pdf/1810.03787.pdf" target="_blank" rel="noopener">arxiv link</a>. </p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Machine Learning has achieved great success in solving classicaly difficult problems. Quantum system containng many-body interactions are extremely large complexity.<br>However, directly applying classical neural network requires performing exponentially difficult quantum state or process tomography. Thus, it would be much more beneficial if we could use quantum states or processes as inputs.</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>Similar to the CNN model, QCNN is constructed below. Input ($\rho_{in}$) is an unknown quantum state. A convolution layer applies a single quasilocal unitary ($U_{i}$) and a fraction of qubits are measured acting as pooling layer. The measurment outcome determine unitary rotation ($V_{j}$) applied to nearby qubits. After convolutional layers, a fully connected layer is applied as a unitary $F$ on the remaining qubits. Finally, the outcome of the circuit is obtained by measuring a fixed number of output qubits. The unitaries here are weights to be optimized in classical CNN during learning process.<br><img src="./qcnn_architecture.PNG" alt><br>For a simple system with binary outputs, the mean squared error is calculated as,<br>$$MSE = \frac{1}{2M}\sum_{\alpha=1}^{M}(y_i-f_{U_i, V_j, F}(|\Psi_\alpha\rangle))^2$$<br>The paper also compares QCNN with the multiscale entanglement renormalization ansatz(MERA) and QEC. I don’t fully understand these parts. Simply speaking, QCNN is like a reverse version of MERA combined with QEC as pooling layers. Please read the paper if you are interested.</p><h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><h3 id="1-Quantum-phase-recognition"><a href="#1-Quantum-phase-recognition" class="headerlink" title="1. Quantum phase recognition"></a>1. Quantum phase recognition</h3><p>The system investigate in the paper is a $Z_2 \times Z_2$ symmetry-protected topological (SPT) phase $\cal {P}$ described by<br>$$H = -J\sum_{i=1}^{N-2}Z_iX_{i+1}Z_{i+2} - h_1\sum_{i=1}^NX_i - h_2\sum_{i=1}^{N-1}X_iX_{i+1}$$<br>Below Fig. a is the phase diagram and Fig. b is the analytical QCNN circuit that they use to recognize $\cal{P}$<br><img src="./application_1.png" alt><br>The training data points are 40 equally spaced points $h_1 \in [0,2]$ along the line $h_2=-0$. The blue and red diamonds are phase boundary points extracted from infinite-size DMRG numerical simulations, while the background shading represents the expectation value of QCNN output. In the QCNN learning procedure, the derivative of the MSE to the first order is calculated with respect to the parameters using the finite-difference method.(See paper method part for detail)</p><p>The output is shown below. It shows that the QCNN can accurately reproduce the two-dimensional phase diagram over the entire parameter regime, while only trained on samples from a set of solvable points that do not even cross the lower phase boundary.</p><p><em>I have one question here: does this mean that the QCNN have learned how to solve the hamiltonian for the whole space? As it can show the phase transition that it is not trained upon.</em><br><img src="./application_1_output.png" alt></p><h3 id="2-Quantum-error-correction-QEC-optimization"><a href="#2-Quantum-error-correction-QEC-optimization" class="headerlink" title="2. Quantum error correction (QEC) optimization"></a>2. Quantum error correction (QEC) optimization</h3><p>Any QCNN circuit can be viewed as a decoding (encoding) quantum channel between the physical input qubits and the logical output qubit. The encoding scheme introduces sets of new qubits in a predetermined state while the decoding scheme performs measurements. </p><table>    <tr>        <td><center><img src="./application_2.png"></center></td>        <td><center><img src="./application_2_output.png"></center></td>    </tr></table>The output is shown above. The performance of the Shor code(blue) is worse than performing no error correction at all(grey line), while the optimized code(orange) can substantially reduce the error rate.<h2 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h2><p>This paper indicates that QCNNs are promising for its application in qunatum machine learning field. Further extensions could incorporate optimizations for fault-tolerant operations on QEC code spaces. </p><p>As I am not familar with quantum computer part, I still quite confuse how they develop their systems. They have included a section of experimental realization in the paper. Also the optimization method in the QCNN is not backpropagation we generally use in classical CNN. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This &lt;a href=&quot;https://doi.org/10.1038/s41567-019-0648-8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;paper&lt;/a&gt; is published on August 26th, 2019 on &lt;em&gt;Nature Physics&lt;/em&gt; by &lt;a href=&quot;http://lukin.physics.harvard.edu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Professor Lukin’s Group&lt;/a&gt; at Harvard University. The first author is &lt;a href=&quot;https://scholar.google.co.uk/citations?user=Zk3TRxYAAAAJ&amp;hl=en&amp;oi=ao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Iris Cong&lt;/a&gt;, a third-year graduate student. Here are a &lt;a href=&quot;(http://www.cchem.berkeley.edu/bqic/slides/qcnn_berkeley_oct18_share.pdf)&quot;&gt;talk slides&lt;/a&gt; and &lt;a href=&quot;https://www.youtube.com/watch?v=ytX6Vfo8WAk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;video&lt;/a&gt; from the author introducing this topic and the &lt;a href=&quot;https://arxiv.org/pdf/1810.03787.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;arxiv link&lt;/a&gt;. &lt;/p&gt;
    
    </summary>
    
    
      <category term="Journal Club" scheme="http://yoursite.com/tags/Journal-Club/"/>
    
  </entry>
  
  <entry>
    <title>Sync Settings of Sublime Text 3</title>
    <link href="http://yoursite.com/2019/09/02/sublime-text-3/"/>
    <id>http://yoursite.com/2019/09/02/sublime-text-3/</id>
    <published>2019-09-02T16:55:24.000Z</published>
    <updated>2019-10-07T21:28:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>For those people using Sublime Text 3, it may feel more convenient to synchronize their own Sublime Text 3 setting across different computers. This can be realized through a plugin called <a href="https://packagecontrol.io/packages/Sync%20Settings" target="_blank" rel="noopener"><code>Sync Setting</code></a> on Sublime Text 3.</p><a id="more"></a><p>The content of this article is mainly based upon <a href="https://zhuanlan.zhihu.com/p/31192452" target="_blank" rel="noopener">this link</a>.</p><ul><li><p><code>Ctrl + Shift + P</code> open package control in ST3, and enter <code>install</code>, choose <code>Package Control: Install Package</code></p></li><li><p>Enter <code>Sync Settings</code>, choose the corresponding one. </p></li><li><p><a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">Generate a new personal Github token</a>. Make sure you choose <code>gist</code> term, and click <code>Generate toker</code>.</p></li><li><p>Copy your token and paste it to <code>Preference &gt; Packages Settings &gt; Sync Settings &gt; Settings - User</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;access_token&quot;: &quot;&lt;your-token&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Preference &gt; Packages Settings &gt; Sync Settings &gt; Sync Settings: Create and Upload</code> and enter your description.</p></li><li><p>Open the user setting file and copy <code>access_token</code> and <code>gist_id</code>.</p></li><li><p>On the computer you need to install settings, install <code>Sync Settings</code> and paste <code>access_token</code> and <code>gist_id</code>. </p></li><li><p><code>Preference &gt; Packages Settings &gt; Sync Settings &gt; Sync Settings: Download</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;For those people using Sublime Text 3, it may feel more convenient to synchronize their own Sublime Text 3 setting across different computers. This can be realized through a plugin called &lt;a href=&quot;https://packagecontrol.io/packages/Sync%20Settings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Sync Setting&lt;/code&gt;&lt;/a&gt; on Sublime Text 3.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Creating Your Own Blog with Github and Hexo</title>
    <link href="http://yoursite.com/2019/08/30/create-hexo-blog/"/>
    <id>http://yoursite.com/2019/08/30/create-hexo-blog/</id>
    <published>2019-08-30T20:48:00.000Z</published>
    <updated>2019-10-07T21:28:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to my first blog! It took me a while to struggle through the setting process of my blog. Thus, I want to share my experience here to help people with same wish creating their own blog with github pages and hexo. </p><a id="more"></a><p>There are already many excellent tutorials about the subject. </p><p>For people want step by step tutorial, you could review following two ariticles,</p><ul><li><a href="https://neveryu.github.io/2016/09/03/hexo-next-one/" target="_blank" rel="noopener">Hexo-NexT搭建个人博客</a></li><li><a href="http://www.zhangblog.com/2019/06/11/hexo01/" target="_blank" rel="noopener">Linux下使用github+hexo搭建个人博客</a></li></ul><p>However, for the plugins or the modification to your theme, I strongly recommend you can view the really detailed documents, <a href="https://hexo-guide.readthedocs.io/zh_CN/latest/index.html#" target="_blank" rel="noopener">hexo NexT theme tutorial</a>.</p><p>The following content are some important things I need to remind myself of.</p><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><p>Download <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js</a> and <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a> first. I personally recommend the LTS version of node.js.</p><p>If you already meet above requirements, you just need using <code>npm</code> to complete <code>Hexo</code> installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>After install hexo, we need to initialize a specific diretory for our blog. Move your working directory to your blog directory,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h2 id="Hexo-common-command"><a href="#Hexo-common-command" class="headerlink" title="Hexo common command"></a>Hexo common command</h2><p>I will only include several common command we use here and if you are interested in learning more, please go to the official website <a href="https://hexo.io/docs/commands" target="_blank" rel="noopener">here</a>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;postname&gt; <span class="comment"># create new article, </span></span><br><span class="line">hexo g <span class="comment"># generate static files</span></span><br><span class="line">hexo s <span class="comment"># local host, default is http://localhost:4000/</span></span><br><span class="line">hexo d <span class="comment"># deploy your website</span></span><br><span class="line">hexo c <span class="comment"># clean temporary files such as db.json and public files</span></span><br></pre></td></tr></table></figure><h2 id="Sync-your-blog-across-multiple-computers"><a href="#Sync-your-blog-across-multiple-computers" class="headerlink" title="Sync your blog across multiple computers"></a>Sync your blog across multiple computers</h2><p>More or less, we may need to manage our blog on different computers, such as on home computer or on your laptop. Then we cannot avoid to meet such a problem: how could we sync our blog?</p><p>This have puzzled me for a lot. At first, I saw people online suggesting creating multiple branches for backing up hexo source files in one repository. </p><ul><li>hexo branch: for Hexo source files</li><li>master branch: for blog source files generated by hexo</li></ul><p>However, this may expose to some secret keys to the public causing some problems if you add third-party plugins in your blogs. Until now, the best way I have ever read is to create two separate repositories, one private for Hexo and one public for blog.  </p><p>Details can be found at <a href="https://ricky.moe/2017/01/13/hexo-perfect-synchronize/" target="_blank" rel="noopener">hexo-perfect-synchronize</a> and <a href="https://segmentfault.com/a/1190000017784822" target="_blank" rel="noopener">segmentfault.com</a>. </p><ol><li>Simply speaking, if you already finished your hexo installation and can deploy your blog to github, you can follow steps below.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make sure you are in your hexo root directory, delete third-party plugins git files</span></span><br><span class="line">rm -rf ./themes/next/.git/</span><br><span class="line"><span class="comment"># establish local git repository</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><ol start="2"><li>create a .gitignore file and put it under hexo root directory. This file may already exists, just check the content whether is same as below,</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><ol start="3"><li>you can push your hexo source files to the github repository you have already created. </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/&lt;username&gt;/&lt;repo-name&gt;.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'my first private hexo'</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><ol start="4"><li>On the other computer, </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo-link&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;git-directory&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ol start="5"><li>When you finish your work on the other computer, push your work to github to update repository.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add . </span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><ol start="6"><li>remember to pull your Hexo repo every time when you want to write a blog and publish it to github,</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h2 id="Customization"><a href="#Customization" class="headerlink" title="Customization"></a>Customization</h2><h3 id="Add-comment-system"><a href="#Add-comment-system" class="headerlink" title="Add comment system"></a>Add comment system</h3><p>Next theme supports multiple comment systems by default. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Available values: changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte</span><br></pre></td></tr></table></figure><p>I have been using livere for a while but finally I gave up due to the slow loading speed. I am now using valine as my comment system. Besides the quick loading speed, one advantage is that it doesn’t require any login information to comment. </p><h4 id="Obtain-APP-ID-and-APP-Key"><a href="#Obtain-APP-ID-and-APP-Key" class="headerlink" title="Obtain APP ID and APP Key"></a>Obtain APP ID and APP Key</h4><p>Register on <a href="https://leancloud.app" target="_blank" rel="noopener">LeanCloud</a> and go to console create an app. Then you could get the <code>APP ID</code> and <code>APP Key</code> on your APP setting page.</p><p>Go to your theme <code>_config.yml</code> file and find the following paragraph. Paste your <code>ID</code> and <code>Key</code>. Change your setting as following.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version</span></span><br><span class="line">  appid:  <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  appkey:  <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  notify: <span class="literal">false</span> <span class="comment"># Mail notifier. See: https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  verify: <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  placeholder: Just go go <span class="comment"># Comment box placeholder</span></span><br><span class="line">  avatar: mm <span class="comment"># Gravatar style</span></span><br><span class="line">  guest_info: nick,mail,link <span class="comment"># Custom comment header</span></span><br><span class="line">  pageSize: 10 <span class="comment"># Pagination size</span></span><br><span class="line">  language: en <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  visitor: <span class="literal">false</span> <span class="comment"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span></span><br><span class="line">  comment_count: <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure><h3 id="Customize-social-icon-in-sidebar"><a href="#Customize-social-icon-in-sidebar" class="headerlink" title="Customize  social icon in sidebar"></a>Customize  social icon in sidebar</h3><p>Open <code>themes/next/_config.yml</code>, find <code>social_icons</code>, and set <code>enable</code> to <code>true</code>. Find your favorite icon in <a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">library</a> and paste its name after your link. </p><h3 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a><a href="https://hexo-guide.readthedocs.io/zh_CN/latest/theme/[NexT]配置MathJax.html" target="_blank" rel="noopener">MathJax</a></h3><p>There are two steps in <code>NexT</code> theme to support math formulas.</p><h4 id="1-Enable-NexT-internal-math-formula-rendering-engine"><a href="#1-Enable-NexT-internal-math-formula-rendering-engine" class="headerlink" title="1. Enable NexT internal math formula rendering engine."></a>1. Enable <code>NexT</code> internal math formula rendering engine.</h4><p>Open <code>themes/next/_config.yml</code>, find <code>math</code> keyword, change <code>enable: false</code> to <code>enable: true</code>. Set <code>per_page</code> to <code>true</code> and add <code>mathjax: true</code> to the articles you need the rendering configurations.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &lt;postname&gt;</span><br><span class="line">date: &lt;datatime&gt;</span><br><span class="line"></span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><h4 id="2-Enable-Hexo-rendering-engine"><a href="#2-Enable-Hexo-rendering-engine" class="headerlink" title="2. Enable Hexo rendering engine."></a>2. Enable <code>Hexo</code> rendering engine.</h4><p>Go to the root directory of your blog. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>Note: it is <strong>renderer</strong> not <strong>render</strong>!</p><p>If you install <code>hexo-renderer-pandoc --save</code>, you probably will counter following error when <code>hexo s</code> to view your blog. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">INFO  Start processing</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: pandoc exited with code 9: pandoc: Unknown extension: smart</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Useful-Tips"><a href="#Useful-Tips" class="headerlink" title="Useful Tips"></a>Useful Tips</h2><h3 id="1-Using-special-characters-in-your-title"><a href="#1-Using-special-characters-in-your-title" class="headerlink" title="1. Using special characters in your title"></a>1. Using special characters in your title</h3><p>In YAML grammar, it is not allowed to use special character such as <code>:</code> or <code>[]</code>. There are two solutions in general.</p><ul><li>use <code>-</code> to replace your special characters</li><li>define all your string using <code>&#39;</code> or <code>&quot;</code>, eg, <code>&quot;title: this is my title&quot;</code></li></ul><h3 id="2-Insert-multiple-figures-in-one-line"><a href="#2-Insert-multiple-figures-in-one-line" class="headerlink" title="2. Insert multiple figures in one line"></a>2. Insert multiple figures in one line</h3><p>You could use <code>HTML</code> grammar to include your images in <code>&lt;table&gt;</code> tag and add your image title. In this way you don’t need to set <code>&lt;width&gt;</code> and <code>&lt;height&gt;</code> in <code>&lt;img&gt;</code>. Here is an example code.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span>image title<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span>image title<span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Problem-Solutions"><a href="#Problem-Solutions" class="headerlink" title="Problem Solutions"></a>Problem Solutions</h2><h3 id="3-Cannot-load-CSS-file"><a href="#3-Cannot-load-CSS-file" class="headerlink" title="3. Cannot load CSS file"></a>3. Cannot load CSS file</h3><p>When I modify my own custom <code>styles.styl</code>, I find <code>hexo s</code> will generate the correct page for while <code>hexo d</code> cannot.<br>The solution is to modify the <code>_config.yml</code> file in hexo root folder.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root: /&lt;your-repo-name&gt;</span><br></pre></td></tr></table></figure><p>And you redeploy your website and it will function normally as your localhost.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my first blog! It took me a while to struggle through the setting process of my blog. Thus, I want to share my experience here to help people with same wish creating their own blog with github pages and hexo. &lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
